<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L·ªùi M·ªùi ƒê·∫∑c Bi·ªát ‚ù§Ô∏è</title>
    <!-- T·∫£i Tailwind CSS ƒë·ªÉ styling --><script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts cho font ch·ªØ ƒë·∫πp m·∫Øt --><link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Quicksand:wght@300..700&display=swap" rel="stylesheet">
    <style>
        /* Thi·∫øt l·∫≠p font cho to√†n b·ªô trang */
        body {
            font-family: 'Quicksand', sans-serif;
            background: linear-gradient(135deg, #f7d4e3 0%, #d4ebf7 100%); /* Gradient l√£ng m·∫°n */
            transition: background-color 0.5s ease;
            overflow: hidden; /* NgƒÉn cu·ªôn khi n√∫t di chuy·ªÉn */
        }
        h1, h2 {
            font-family: 'Pacifico', cursive; /* Font ch·ªØ vi·∫øt tay cho ti√™u ƒë·ªÅ */
        }
        /* Class cho n√∫t c√≥ th·ªÉ di chuy·ªÉn */
        .movable-button {
            transition: all 0.2s ease-out; /* T·∫°o chuy·ªÉn ƒë·ªông m∆∞·ª£t */
            position: absolute;
            white-space: nowrap; /* NgƒÉn ch·ªØ b·ªã ng·∫Øt d√≤ng */
        }
        /* Hi·ªáu ·ª©ng h·∫°t r∆°i nh·∫π nh√†ng */
        .heart-particle {
            position: absolute;
            background-color: rgba(255, 105, 180, 0.7); /* M√†u h·ªìng */
            border-radius: 50%;
            animation: fall linear infinite;
            pointer-events: none; /* Kh√¥ng ch·∫∑n click */
            opacity: 0;
        }

        @keyframes fall {
            0% { transform: translateY(-10vh) scale(0.5); opacity: 0; }
            10% { opacity: 1; }
            100% { transform: translateY(100vh) scale(1.5); opacity: 0; }
        }

        /* Custom animation for fade in */
        @keyframes fadeIn {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fadeIn 1.5s ease-out forwards;
        }
        
        /* Spinner CSS */
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ec4899; /* Pink-500 */
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 8px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Toast Message CSS */
        #toast-message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 8px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            pointer-events: none;
        }
        #toast-message.show {
            opacity: 1;
            transform: translateX(-50%) translateY(-10px);
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen">

    <!-- Audio Element (Kh√¥ng c√≥ source c·ªë ƒë·ªãnh, s·∫Ω ƒë∆∞·ª£c t·∫£i b·∫±ng JS/TTS) -->
    <audio id="confession-audio" preload="auto"></audio>

    <!-- Toast Message (Th√¥ng b√°o cho ng∆∞·ªùi d√πng) -->
    <div id="toast-message"></div>

    <!-- AUDIO FIX OVERLAY (M·ªöI) - Hi·ªÉn th·ªã khi Autoplay b·ªã ch·∫∑n -->
    <div id="audio-fix-prompt" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center cursor-pointer p-4">
        <div class="bg-white p-6 rounded-xl shadow-2xl text-center transition-all duration-300 transform hover:scale-105">
            <p class="text-4xl mb-4">üîä</p>
            <p class="text-2xl text-red-600 font-bold mb-2">√Çm thanh b·ªã ch·∫∑n!</p>
            <p class="text-gray-700 font-medium">B·∫•m v√†o b·∫•t k·ª≥ ƒë√¢u tr√™n h·ªôp n√†y ƒë·ªÉ M·ªü Kh√≥a √¢m thanh!</p>
        </div>
    </div>
    
    <!-- Container ch√≠nh --><div id="main-container" class="relative z-10 text-center p-8 md:p-12 bg-white/90 backdrop-blur-md rounded-3xl shadow-3xl transition-all duration-700 w-11/12 max-w-lg border-2 border-pink-200 animate-fade-in-down">

        <!-- N·ªôi dung ch√≠nh (C√¢u h·ªèi) --><h1 id="question-text" class="text-3xl sm:text-4xl lg:text-5xl font-extrabold text-pink-600 mb-8 transition-all duration-700 leading-tight">
            Ch√†o b·∫°n! B·∫°n c√≥ mu·ªën c√πng m√¨nh t·∫°o n√™n m·ªôt k·ª∑ ni·ªám ƒë·∫∑c bi·ªát cu·ªëi tu·∫ßn n√†y kh√¥ng?
        </h1>

        <!-- Khu v·ª±c ch·ª©a c√°c n√∫t t∆∞∆°ng t√°c --><div class="flex flex-col sm:flex-row justify-center items-center relative space-y-4 sm:space-y-0 sm:space-x-8 min-h-[120px] sm:min-h-[100px]">

            <!-- N√∫t C√ì (D·ªÖ d√†ng b·∫•m) --><button id="yes-button" onclick="handleYesClick()"
                class="px-10 py-4 bg-gradient-to-r from-green-400 to-emerald-500 text-white font-bold text-xl rounded-full shadow-lg hover:from-green-500 hover:to-emerald-600 transform hover:scale-105 transition-all duration-300 z-20 focus:outline-none focus:ring-4 focus:ring-green-300">
                Ch·∫Øc ch·∫Øn R·ªíI! ü•∞
            </button>

            <!-- N√∫t KH√îNG (N√∫t di chuy·ªÉn) -->
            <button id="no-button" onmouseenter="moveNoButton()" onclick="handleNoClick()"
                class="movable-button px-8 py-3 bg-gradient-to-r from-red-400 to-rose-500 text-white font-bold text-lg rounded-full shadow-md hover:from-red-500 hover:to-rose-600 transition-all duration-300 z-10 focus:outline-none focus:ring-4 focus:ring-red-300">
                KH√îNG
            </button>

        </div>
        
        <!-- T√≠nh nƒÉng Gemini: L·ªùi Ng·ªçt Ng√†o -->
        <div class="mt-10 pt-4 border-t border-pink-200">
            <h3 class="text-xl font-semibold text-pink-500 mb-3 font-quicksand">Th·ª≠ v·∫≠n may! L·ªùi Ng·ªçt Ng√†o ‚ú®</h3>
            <p id="gemini-compliment" class="text-lg text-gray-700 min-h-[40px] italic mb-4 p-2 bg-pink-50 rounded-lg border border-pink-100 shadow-inner flex items-center justify-center">
                H√£y nh·∫•n n√∫t ƒë·ªÉ nh·∫≠n m·ªôt c√¢u n√≥i l√£ng m·∫°n b·∫•t ng·ªù!
            </p>
            <button id="generate-button" onclick="generateCompliment()"
                class="px-6 py-2 bg-gradient-to-r from-purple-400 to-indigo-500 text-white font-bold rounded-full shadow-lg hover:from-purple-500 hover:to-indigo-600 transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-purple-300 disabled:opacity-50">
                Nh·∫≠n L·ªùi M·∫≠t Ng·ªçt
            </button>
        </div>

    </div>

    <!-- Container ch·ª©a l·ªùi t·ªè t√¨nh b√≠ m·∫≠t (Ban ƒë·∫ßu ·∫©n) --><div id="confession-container" class="hidden fixed inset-0 bg-gradient-to-br from-pink-50 to-purple-100 flex flex-col items-center justify-center text-center p-8 z-20 animate-fade-in-bg">
        <div class="relative bg-white p-10 md:p-12 rounded-3xl shadow-2xl max-w-lg animate-pulse-slow border-4 border-pink-300">
            <p class="text-7xl mb-6 animate-bounce-custom">üíñ</p>
            <h2 class="text-4xl md:text-5xl font-bold text-pink-700 mb-4 animate-fade-in">B·∫•t Ng·ªù Ch∆∞a!</h2>
            <p class="text-xl md:text-2xl text-gray-700 animate-fade-in animation-delay-500">
                Th·∫≠t ra, l·ªùi m·ªùi ƒëi ch∆°i ch·ªâ l√† c√°i c·ªõ th√¥i. ƒêi·ªÅu m√¨nh mu·ªën n√≥i l√†:
            </p>
            <p class="text-5xl md:text-6xl font-extrabold text-red-600 mt-6 animate-fade-in animation-delay-1000 leading-tight">
                M√åNH TH√çCH B·∫†N R·∫§T NHI·ªÄU!
            </p>
            <p class="text-lg md:text-xl text-gray-600 mt-4 animate-fade-in animation-delay-1500">Hy v·ªçng b·∫°n c≈©ng c·∫£m th·∫•y nh∆∞ v·∫≠y...</p>

            <!-- T√≠nh nƒÉng Gemini M·ªöI: K·∫ø ho·∫°ch H·∫πn H√≤ B√≠ M·∫≠t -->
            <div class="mt-8 pt-4 border-t border-pink-200 w-full animate-fade-in animation-delay-2000">
                <h3 class="text-2xl font-semibold text-purple-600 mb-3 font-quicksand">üéâ K·∫ø Ho·∫°ch ƒê·∫∑c Bi·ªát Cho Ch√∫ng Ta</h3>
                <p id="gemini-date-idea" class="text-base text-gray-700 min-h-[50px] italic p-3 bg-purple-50 rounded-lg border border-purple-100 shadow-inner flex items-center justify-center">
                    ... (Ch·ªù √Ω t∆∞·ªüng) ...
                </p>
                <button id="date-idea-button" onclick="generateDateIdea()" disabled
                    class="mt-3 px-6 py-2 bg-gradient-to-r from-purple-600 to-indigo-700 text-white font-bold rounded-full shadow-lg transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-purple-400 disabled:opacity-50">
                    Nh·∫≠n √ù T∆∞·ªüng H·∫πn H√≤ B·∫•t Ng·ªù
                </button>
            </div>

            <div class="absolute -bottom-4 -right-4 bg-yellow-300 p-2 rounded-full transform rotate-12 shadow-lg">
                <span class="text-2xl">üòä</span>
            </div>
            <div class="absolute -top-4 -left-4 bg-blue-300 p-2 rounded-full transform -rotate-12 shadow-lg">
                <span class="text-2xl">üåü</span>
            </div>
        </div>
    </div>

    <script>
        const noButton = document.getElementById('no-button');
        const mainContainer = document.getElementById('main-container');
        const questionText = document.getElementById('question-text');
        const yesButton = document.getElementById('yes-button');
        const confessionContainer = document.getElementById('confession-container');
        const confessionAudio = document.getElementById('confession-audio');
        const toastMessage = document.getElementById('toast-message');
        const audioFixPrompt = document.getElementById('audio-fix-prompt'); // N√∫t m·ªü kh√≥a √¢m thanh
        
        // Gemini API Constants and Elements
        const apiKey = "";
        const LLM_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=";
        const TTS_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=";
        const complimentDisplay = document.getElementById('gemini-compliment');
        const generateButton = document.getElementById('generate-button');
        const dateIdeaDisplay = document.getElementById('gemini-date-idea');
        const dateIdeaButton = document.getElementById('date-idea-button');

        let moveCount = 0; // ƒê·∫øm s·ªë l·∫ßn n√∫t KH√îNG b·ªã di chuy·ªÉn
        const maxMoves = 6; // S·ªë l·∫ßn di chuy·ªÉn tr∆∞·ªõc khi chuy·ªÉn sang m√†n t·ªè t√¨nh

        // --- H√ÄM H·ªñ TR·ª¢ CHUNG ---

        // H√†m hi·ªÉn th·ªã Toast Message
        function showToast(message) {
            toastMessage.textContent = message;
            toastMessage.classList.add('show');
            setTimeout(() => {
                toastMessage.classList.remove('show');
            }, 4000); // ·∫®n sau 4 gi√¢y
        }

        // H√†m hi·ªÉn th·ªã tr·∫°ng th√°i Loading
        function showLoading(element, text = "ƒêang t·∫£i...") {
            element.innerHTML = `<span class="spinner"></span> ${text}`;
        }

        // H√†m h·ªó tr·ª£ fetch v·ªõi c∆° ch·∫ø exponential backoff retry
        async function fetchWithRetry(url, options, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        if (response.status === 429 && i < maxRetries - 1) {
                            const delay = Math.pow(2, i) * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue;
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    if (i === maxRetries - 1) {
                        console.error("Fetch failed after multiple retries:", error);
                        throw error;
                    }
                }
            }
        }
        
        // --- C√ÅC H√ÄM X·ª¨ L√ù AUDIO (PCM to WAV) ---

        // H√†m chuy·ªÉn Base64 sang ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // H√†m chuy·ªÉn PCM 16-bit th√†nh WAV Blob
        function pcmToWav(pcm16Data, sampleRate) {
            const numChannels = 1;
            const bytesPerSample = 2; // 16-bit PCM
            const pcmData = new DataView(pcm16Data.buffer);
            const pcmLength = pcmData.byteLength;
            const buffer = new ArrayBuffer(44 + pcmLength); // 44 bytes for WAV header

            const view = new DataView(buffer);
            let offset = 0;

            // RIFF chunk
            view.setUint32(offset, 0x52494646, false); offset += 4; // "RIFF"
            view.setUint32(offset, 36 + pcmLength, true); offset += 4; // ChunkSize
            view.setUint32(offset, 0x57415645, false); offset += 4; // "WAVE"

            // FMT chunk
            view.setUint32(offset, 0x666d7420, false); offset += 4; // "fmt "
            view.setUint32(offset, 16, true); offset += 4; // Subchunk1Size (16 for PCM)
            view.setUint16(offset, 1, true); offset += 2; // AudioFormat (1 for PCM)
            view.setUint16(offset, numChannels, true); offset += 2; // NumChannels
            view.setUint32(offset, sampleRate, true); offset += 4; // SampleRate
            view.setUint32(offset, sampleRate * numChannels * bytesPerSample, true); offset += 4; // ByteRate
            view.setUint16(offset, numChannels * bytesPerSample, true); offset += 2; // BlockAlign
            view.setUint16(offset, 16, true); offset += 2; // BitsPerSample

            // DATA chunk
            view.setUint32(offset, 0x64617461, false); offset += 4; // "data"
            view.setUint32(offset, pcmLength, true); offset += 4; // Subchunk2Size

            // Write PCM data
            for (let i = 0; i < pcmLength; i++) {
                view.setInt8(offset + i, pcmData.getInt8(i));
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        // H√†m g·ªçi TTS API v√† tr·∫£ v·ªÅ URL audio
        async function generateTtsAudio(textToSpeak) {
            showToast("ƒêang t·∫°o l·ªùi t·ªè t√¨nh b·∫±ng gi·ªçng n√≥i... üé§");
            const ttsPayload = {
                contents: [{
                    parts: [{ text: `Say in a gentle and sincere tone: ${textToSpeak}` }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        // S·ª≠ d·ª•ng gi·ªçng Kore (m·ªôt gi·ªçng nam r√µ r√†ng, ph√π h·ª£p cho t·ªè t√¨nh)
                        voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } }
                    }
                },
            };

            try {
                const result = await fetchWithRetry(`${TTS_API_URL}${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(ttsPayload)
                });

                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                    // L16 l√† PCM 16-bit. C·∫ßn tr√≠ch xu·∫•t sample rate
                    const rateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000; // M·∫∑c ƒë·ªãnh 24000 n·∫øu kh√¥ng t√¨m th·∫•y

                    const pcmBuffer = base64ToArrayBuffer(audioData);
                    const wavBlob = pcmToWav(new Int16Array(pcmBuffer), sampleRate);
                    return URL.createObjectURL(wavBlob);
                } else {
                    return null; // L·ªói ƒë·ªãnh d·∫°ng TTS
                }
            } catch (error) {
                console.error("TTS API call failed:", error);
                return null;
            }
        }
        
        // --- GEMINI API: T·∫†O L·ªúI NG·ªåT NG√ÄO (Pre-Confession) ---
        async function generateCompliment() {
            showLoading(complimentDisplay, "ƒêang nghƒ© l·ªùi ng·ªçt ng√†o... üíñ");
            generateButton.disabled = true;

            const systemPrompt = "You are a Vietnamese romantic poet and sweet compliment generator. Generate a unique, short, and extremely sweet one-sentence compliment or romantic phrase in Vietnamese. It must be surprising and heartwarming. Do not include any title, introduction, or markdown formatting.";
            const userQuery = "Vi·∫øt m·ªôt l·ªùi khen ng·ª£i/t√¨nh c·∫£m ng·∫Øn v√† b·∫•t ng·ªù d√†nh cho ng∆∞·ªùi t√¥i y√™u.";

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            try {
                const result = await fetchWithRetry(`${LLM_API_URL}${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                if (text) {
                    complimentDisplay.textContent = `"${text.trim()}"`;
                } else {
                    complimentDisplay.textContent = "√îi kh√¥ng, l·ªùi ng·ªçt ng√†o b·ªã l·∫°c r·ªìi. Th·ª≠ l·∫°i nh√©!";
                }

            } catch (error) {
                complimentDisplay.textContent = "Kh√¥ng th·ªÉ t·∫°o l·ªùi ng·ªçt ng√†o l√∫c n√†y. V·∫•n ƒë·ªÅ m·∫°ng ho·∫∑c API.";
            } finally {
                generateButton.disabled = false;
            }
        }

        // --- GEMINI API: T·∫†O √ù T∆Ø·ªûNG H·∫∏N H√í (Post-Confession) ---
        async function generateDateIdea() {
            showLoading(dateIdeaDisplay, "ƒêang t·∫°o ra k·∫ø ho·∫°ch h·∫πn h√≤ l√£ng m·∫°n... üíå");
            dateIdeaButton.disabled = true;

            const systemPrompt = "You are a creative and romantic event planner. Generate a single, short, and unique date idea suitable for a first date in Vietnamese. The tone must be exciting and sweet. The idea must be creative and actionable. Do not include any title, introduction, or markdown formatting, just the idea.";
            const userQuery = "G·ª£i √Ω m·ªôt √Ω t∆∞·ªüng h·∫πn h√≤ ƒë·∫ßu ti√™n th·∫≠t l√£ng m·∫°n v√† ƒë·ªôc ƒë√°o ·ªü Vi·ªát Nam, kh√¥ng ph·∫£i l√† ƒëi xem phim hay ƒÉn t·ªëi.";

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            try {
                const result = await fetchWithRetry(`${LLM_API_URL}${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                if (text) {
                    dateIdeaDisplay.textContent = `"${text.trim()}"`;
                } else {
                    dateIdeaDisplay.textContent = "Kh√¥ng th·ªÉ nghƒ© ra k·∫ø ho·∫°ch. T·ª± m√¨nh t·∫°o n√™n k·ª∑ ni·ªám nh√©!";
                }

            } catch (error) {
                dateIdeaDisplay.textContent = "L·ªói k·∫øt n·ªëi. Kh√¥ng th·ªÉ t·∫°o √Ω t∆∞·ªüng h·∫πn h√≤.";
            } finally {
                dateIdeaButton.disabled = false;
            }
        }
        // --- K·∫æT TH√öC C√ÅC H√ÄM GEMINI API ---

        // H√†m t·∫°o h·∫°t r∆°i
        function createHeartParticle() {
            const particle = document.createElement('div');
            particle.classList.add('heart-particle');
            document.body.appendChild(particle);

            const size = Math.random() * 20 + 10; // K√≠ch th∆∞·ªõc t·ª´ 10px ƒë·∫øn 30px
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.left = `${Math.random() * 100}vw`; // V·ªã tr√≠ ng·∫´u nhi√™n theo chi·ªÅu ngang
            particle.style.animationDuration = `${Math.random() * 3 + 2}s`; // Th·ªùi gian r∆°i ng·∫´u nhi√™n
            particle.style.animationDelay = `${Math.random() * 2}s`; // ƒê·ªô tr·ªÖ ng·∫´u nhi√™n
            
            // X√≥a h·∫°t sau khi r∆°i xong
            particle.addEventListener('animationend', () => {
                particle.remove();
            });
        }

        // T·∫°o hi·ªáu ·ª©ng h·∫°t r∆°i li√™n t·ª•c
        setInterval(createHeartParticle, 300); // M·ªói 300ms t·∫°o m·ªôt h·∫°t m·ªõi

        // H√†m di chuy·ªÉn n√∫t KH√îNG ra xa chu·ªôt
        function moveNoButton() {
            if (moveCount >= maxMoves) {
                noButton.textContent = "B·∫•m C√ì ƒëi m√†! ü•∫";
                return;
            }

            moveCount++;

            const messages = [
                "·ª¶a, sao n√© v·∫≠y? ü§î Ch·∫Øc c√≥ l√Ω do ch·ª©?",
                "Ch·∫Øc ch·∫Øn ch∆∞a? Nghƒ© k·ªπ nha, c∆° h·ªôi hi·∫øm c√≥ ƒë√≥!",
                "Th√¥i, ƒë·ª´ng c·ª©ng ƒë·∫ßu n·ªØa m√† ü•∫. B·∫•m C√ì ƒëi cho m√¨nh vui n√®!",
                "N√∫t C√ì ·ªü ngay b√™n kia k√¨a, sao kh√¥ng b·∫•m...?",
                "L·∫ßn cu·ªëi nha! C·ªë g·∫Øng b·∫•m C√ì ƒëi, ƒë·ª´ng ƒë·ªÉ m√¨nh th·∫•t v·ªçng!",
                "Th√¥i ƒë∆∞·ª£c r·ªìi, m√¨nh bi·∫øt b·∫°n mu·ªën b·∫•m C√ì m√†. H√£y l√†m ƒëi! ‚ù§Ô∏è",
            ];
            questionText.textContent = messages[moveCount - 1] || messages[0];
            
            const containerRect = mainContainer.getBoundingClientRect();
            const buttonRect = noButton.getBoundingClientRect();

            let newX, newY;
            const padding = 20;

            newX = Math.random() * (containerRect.width - buttonRect.width - 2 * padding) + padding;
            newY = Math.random() * (containerRect.height - buttonRect.height - 2 * padding) + padding;

            noButton.style.left = `${newX}px`;
            noButton.style.top = `${newY}px`;
            noButton.style.transform = 'translate(-50%, -50%)';
        }

        // X·ª≠ l√Ω khi b·∫•m n√∫t KH√îNG (Tr√°nh s·ª± c·ªë) - ƒê√É C·∫¢I TI·∫æN
        function handleNoClick() {
            showToast("‚ùå Kh√¥ng ƒë∆∞·ª£c b·∫•m n√∫t KH√îNG! B·∫°n ch·ªâ c√≥ th·ªÉ b·∫•m n√∫t C√ì th√¥i! üòâ");
            // Kh√¥ng thay ƒë·ªïi questionText ƒë·ªÉ tr√°nh ghi ƒë√® l√™n th√¥ng b√°o t·ª´ onmouseenter
        }

        // X·ª≠ l√Ω khi b·∫•m n√∫t C√ì (M·ª•c ti√™u)
        function handleYesClick() {
            // ƒê·∫£m b·∫£o √¢m thanh ph√°t khi t∆∞∆°ng t√°c (ƒë√¢y l√† user gesture, n√™n s·∫Ω ho·∫°t ƒë·ªông)
            if (confessionAudio.src) {
                confessionAudio.play().catch(error => {
                    console.error("Audio playback failed on YES click (might be already playing or system error):", error);
                });
            }


            // ·∫®n n·ªôi dung hi·ªán t·∫°i v√† hi·ªÉn th·ªã l·ªùi t·ªè t√¨nh
            mainContainer.classList.add('opacity-0', 'scale-90');
            setTimeout(() => {
                mainContainer.classList.add('hidden');
                document.body.classList.remove('bg-gray-50');
                document.body.classList.add('bg-pink-100');
                confessionContainer.classList.remove('hidden');
                confessionContainer.classList.add('animate-fade-in');
                
                // K√≠ch ho·∫°t t√≠nh nƒÉng H·∫πn H√≤ B√≠ M·∫≠t sau khi t·ªè t√¨nh
                dateIdeaButton.disabled = false;
                generateDateIdea(); 
            }, 500);
        }

        // --- X·ª¨ L√ù AUTOPLAY KHI T·∫¢I TRANG (ƒê√£ t√≠ch h·ª£p TTS) ---
        async function playAudioOnLoad() {
            confessionAudio.volume = 0.8; 
            
            // 1. Generate TTS Audio for the message "t√¥i y√™u trang ƒë√†m ·∫°"
            const audioUrl = await generateTtsAudio("t√¥i y√™u trang ƒë√†m ·∫°");

            if (audioUrl) {
                confessionAudio.src = audioUrl;

                // 2. Try to play it
                confessionAudio.play()
                    .then(() => {
                        showToast("üé∂ L·ªùi t·ªè t√¨nh 't√¥i y√™u trang ƒë√†m ·∫°' ƒë√£ ƒë∆∞·ª£c ph√°t t·ª± ƒë·ªông. R·∫•t l√£ng m·∫°n!");
                        audioFixPrompt.classList.add('hidden'); // ·∫®n n·∫øu th√†nh c√¥ng
                    })
                    .catch(error => {
                        // 3. Autoplay blocked -> Show overlay prompt
                        showToast("üîá Tr√¨nh duy·ªát ƒë√£ ch·∫∑n t·ª± ƒë·ªông ph√°t. H√£y b·∫•m v√†o m√†n h√¨nh ƒë·ªÉ m·ªü kh√≥a √¢m thanh.");
                        audioFixPrompt.classList.remove('hidden');
                        
                        // Add listener to unlock audio on first click on the prompt
                        audioFixPrompt.onclick = function() {
                            confessionAudio.play().then(() => {
                                audioFixPrompt.classList.add('hidden');
                                showToast("‚úÖ √Çm thanh ƒë√£ ƒë∆∞·ª£c m·ªü kh√≥a!");
                                // Remove the click listener after successful unlock
                                audioFixPrompt.onclick = null; 
                            }).catch(console.error);
                        };
                        console.error("Autoplay blocked:", error);
                    });
            } else {
                showToast("‚ö†Ô∏è L·ªói t·∫°o √¢m thanh TTS. V·∫•n ƒë·ªÅ m·∫°ng ho·∫∑c API.");
            }
        }
        // ------------------------------------


        // Thi·∫øt l·∫≠p v·ªã tr√≠ ban ƒë·∫ßu cho n√∫t KH√îNG v√† ch·∫°y Audio khi t·∫£i trang
        window.onload = () => {
             const yesRect = yesButton.getBoundingClientRect();
             const mainRect = mainContainer.getBoundingClientRect();

             // ƒê·∫∑t v·ªã tr√≠ ban ƒë·∫ßu c·ªßa n√∫t KH√îNG g·∫ßn n√∫t C√ì
             noButton.style.left = `${yesRect.right + 60 - mainRect.left}px`;
             noButton.style.top = `${yesRect.top + yesRect.height / 2 - noButton.offsetHeight / 2 - mainRect.top}px`;
             noButton.style.position = 'absolute';
             noButton.style.transform = 'none';

             // CH·∫†Y AUDIO KHI T·∫¢I TRANG
             playAudioOnLoad();
        }

        // C√°c keyframes t√πy ch·ªânh (c√≥ th·ªÉ th√™m v√†o file CSS ri√™ng ho·∫∑c th·∫ª <style>)
        const styleSheet = document.createElement("style");
        styleSheet.type = "text/css";
        styleSheet.innerHTML += `
            @keyframes fade-in-down {
                0% { opacity: 0; transform: translateY(-20px); }
                100% { opacity: 1; transform: translateY(0); }
            }
            .animate-fade-in-down {
                animation: fade-in-down 1s ease-out forwards;
            }
            @keyframes fade-in-bg {
                0% { opacity: 0; }
                100% { opacity: 1; }
            }
            .animate-fade-in-bg {
                animation: fade-in-bg 1s ease-out forwards;
            }
            .shadow-3xl {
                box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25), 0 0 0 10px rgba(255, 192, 203, 0.3);
            }
        `;
        document.head.appendChild(styleSheet);

    </script>
</body>
</html>
